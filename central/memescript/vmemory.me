meme central:memescript/0.0.3/compiler

@author: Thiago Silva <thiago@memetalk.org>;
@license: MIT;

requires bits, mec, io, mirror
where
  bits     = central:memescript/0.0.3/bits
  mec      = central:memescript/0.0.3/mec
  io       = central:linux/0.0.1/io
  mirror = central:reflection/0.0.1/mirror
  import Mirror from mirror
end

class Cell
fields: etable;
init new: fun(etable) {
  @etable = etable;
}
instance_method index: fun() {
  return @etable.offset + @etable.entries.index(this);
}
instance_method etable: fun() {
  return @etable;
}
end


class NullCell < Cell
instance_method size: fun() {
  return bits.WSIZE;
}
instance_method value: fun(_) {
  return bits.bytelist(0);
}
end

class IntCell < Cell
fields: num;
init new: fun(etable, num) {
  super.new(etable);
  if (num == true) {
    @num = 1;
  } elif (num == false or num == null) {
    @num = 0;
  } else {
    @num = num;
  }
}
instance_method size: fun() {
  return bits.WSIZE;
}
instance_method value: fun(_) {
  return bits.bytelist(@num);
}
end

class TaggedIntCell < Cell
fields: num;
init new: fun(etable, num) {
  super.new(etable);
  @num = num;
}
instance_method size: fun() {
  return bits.WSIZE;
}
instance_method value: fun(_) {
  return bits.bytelist_tag(@num);
}
end

class StringCell < Cell
fields: data;
init new: fun(etable, string) {
  super.new(etable);

  var string_with_term = string + "\0";
  //words_needed = int(math.ceil(len(string_with_term) / float(utils.WSIZE)))
  //to_fill = (words_needed * utils.WSIZE) - len(string_with_term)
  var to_fill = bits.string_block_size(string_with_term) - string_with_term.size;
  @data = string_with_term.map(fun(x) { x.toByte }) + ([0].times(to_fill));
}
instance_method size: fun() {
  return @data.size();
}
instance_method value: fun(_) {
  return @data;
}
end

class PointerCell < Cell
fields: target_label, target_cell;
init new: fun(etable, label, cell) { //label/cell: defaults to null
  super.new(etable);
  @target_label = label;
  @target_cell = cell;

  if (@target_label == null and @target_cell == null) {
    Exception.throw("label or cell required");
  }
}
instance_method size: fun() {
  return bits.WSIZE;
}
instance_method target_cell: fun() {
  return @target_cell;
}
instance_method target_label: fun() {
  return @target_label;
}

instance_method is_target_reachable: fun() {
  //assumes `target_cell` always exists in etable
  if (@target_cell) {
    return true;
  } else {
    return this.etable.index.has(@target_label);
  }
}
instance_method value: fun(_) {
  if (@target_cell) {
    return bits.bytelist(this.etable.base + this.etable.opt_physical_addresses[@target_cell]);
  } else {
    return bits.bytelist(this.etable.base + this.etable.index[@target_label]);
  }
}
end


class VirtualMemory
fields: cells, index, base, cell_index,
      //opt
      total_size,
      opt_cell_indexes,
      opt_ptr_cells,
      opt_physical_addresses,
      symb_references,
      opt_object_table,
      opt_pending_ptr;

init new: fun() {
  @cells = [];
  @index = {}; //label -> memory pos
  @base = 0;
  @cell_index = {}; //label -> cells index

  //opt
  @total_size = 0;
  @opt_cell_indexes = {};
  @opt_ptr_cells = [];
  @opt_physical_addresses = {};
  @symb_references = [];
  @opt_object_table = [];
  @opt_pending_ptr = {};

}
instance_method index: fun() {
  return @index;
}
instance_method base: fun() {
  return @base;
}
instance_method cells: fun() {
  return @cells;
}
instance_method opt_physical_addresses: fun() {
  return @opt_physical_addresses;
}
instance_method _append_cell: fun(cell, label) {
  if (label != null) {
    this.label_current(label);
  }
  @cells.append(cell);

  //opt
  @opt_physical_addresses[cell] = @total_size;
  @total_size = @total_size + cell.size;
  @opt_cell_indexes[cell] = @cells.size -1; // subst @cells.index(cell)
  if (Mirror.vtFor(cell) == PointerCell) {
    @opt_ptr_cells.append(cell);

    if (cell.is_target_reachable()) {
      @opt_object_table.extend(cell.value(null));
    } else {
      if (!@opt_pending_ptr.has(cell.target_label)) {
        @opt_pending_ptr[cell.target_label] = [];
      }
      @opt_pending_ptr[cell.target_label].append([cell, @opt_object_table.size]);
      @opt_object_table.extend(bits.bytelist(0xDDDDDDDD));
    }
  } else {
    @opt_object_table.extend(cell.value(null));
  }
}
instance_method set_base: fun(base) {
  @base = base;
}
instance_method label_current: fun(label) {
  if (@index.has(label)) {
    Exception.throw("Duplicated label " + label);
  }
  @index[label] = @total_size;
  @cell_index[label] = @cells.size;

  if (@opt_pending_ptr.has(label)) {
    var lst = @opt_pending_ptr[label];
    for (var i = 0; i < lst.size; i += 1) {
      var entry = @opt_pending_ptr[label][i];
      var c = entry[0];
      var ot_addr = entry[1];
      var new_val = c.value(null);
      @opt_object_table.replace(ot_addr, ot_addr + new_val.size, new_val);
    }
    @opt_pending_ptr.delete(label);
  }
}
instance_method get_pointer_to: fun(label) {
  return @cells[@cell_index[label]];
}
instance_method append_int: fun(num, label) { //label defaults to null
  var cell = IntCell.new(this, num);
  this._append_cell(cell, label);
  return cell;
}
instance_method append_tagged_int: fun(num, label) { //label defaults to null
  var cell = TaggedIntCell.new(this, num);
  this._append_cell(cell, label);
  return cell;
}
instance_method append_null: fun(label) { //label defaults to null
  var cell = NullCell.new(this);
  this._append_cell(cell, label);
  return cell;
}
instance_method append_string: fun(string, label) { //label defaults to null
  var cell = StringCell.new(this, string);
  this._append_cell(cell, label);
  return cell;
}
instance_method append_pointer_to: fun(target_cell, label) { //label defaults to null
  var cell = PointerCell.new(this, null, target_cell);
  this._append_cell(cell, label);
  if (this.symbol_table.keys.has(target_cell)) {
    @symb_references.append([this.symbol_table[target_cell], this.physical_address(cell)]);
  }
  return cell;
}
instance_method append_label_ref: fun(target_label, label) { //label defaults to null
  var cell = PointerCell.new(this, target_label, null);
  this._append_cell(cell, label);
  return cell;
}

//////

instance_method physical_address: fun(cell) {
//  return bench("vmemory:physical_address", fun() {
//    return @base + @cell_sizes.range(0, @cells.pos(cell)).reduce(0, fun(x,y) { x + y});
//  });
  return @base + @opt_physical_addresses[cell];

}
instance_method object_table: fun() {
   return @opt_object_table;
//   // return bench("vmemory:object_table", fun() {
//   //   return @cells.map(fun(c) { c.value(null) }).sum();
//   // });

// //  return bench("vmemory:object_table", fun() {
//   var res = [null].times(@total_size);
//   var x = 0;
//   for (var i = 0; i < @cells.size; i += 1) {
//     var sub = @cells[i].value(null);
//     for (var j = 0; j < sub.size; j += 1) {
//       res[x] = sub[j];
//       x = x + 1;
//     }
//   }
//   return res;
// //  });
}
instance_method reloc_table: fun() {
  // return bench("vmemory:reloc_table", fun() {
  //   return @cells.filter(fun(entry) { Mirror.vtFor(entry) == PointerCell }).map(fun(entry) { this.physical_address(entry) });
  // });
//  return bench("vmemory:reloc_table", fun() {
    return @opt_ptr_cells.map(fun(entry) { this.physical_address(entry) });
//  });
}
instance_method symbols_references: fun() {
  return @symb_references;
// //  return bench("vmemory:symbols_references", fun() {
//     var sr = [];
//     var st = this.symbol_table;
//     for (var i = 0; i < st.size; i += 1) {
//       var entry = st[i];
//       var text = entry[0];
//       var ptr = entry[1];
//       var filtered = @opt_ptr_cells.filter(fun(x) { x.target_cell == ptr });
//       for (var j = 0; j < filtered.size; j += 1) {
//         var referer = filtered[j];
//         sr.append([text, this.physical_address(referer)]);
//       }
//     }
//     return sr.ordered_by(fun(x, y) { x[1] <= y[1] });
// //  });
  // return @symb_references;
// //  return bench("vmemory:symbols_references", fun() {
//     var sr = [];
//     var st = this.symbol_table;
//     for (var i = 0; i < st.size; i += 1) {
//       var entry = st[i];
//       var text = entry[0];
//       var ptr = entry[1];
//       var filtered = @opt_ptr_cells.filter(fun(x) { x.target_cell == ptr });
//       for (var j = 0; j < filtered.size; j += 1) {
//         var referer = filtered[j];
//         sr.append([text, this.physical_address(referer)]);
//       }
//     }
//     return sr;
// //  });
}
instance_method append_int_to_int_dict: fun(mdict) {
  var pairs_oop = [];
  mdict.keys.sorted.each(fun(_, key) {
    var val = mdict[key];
    pairs_oop.append([key, val]);
  });
  return this.append_dict_with_pairs(pairs_oop);
}
instance_method append_int_to_int_list: fun(mdict) {
  var pairs_oop = [];
  mdict.keys.sorted.each(fun(_, key) {
    var val = mdict[key];
    var val_oop = this.append_list_of_ints(val);
    pairs_oop.append([key, val_oop]);
  });
  return this.append_dict_with_pairs(pairs_oop);
}
instance_method append_symbol_to_int_dict: fun(mdict) {
  var pairs_oop = [];
  mdict.keys.sorted.each(fun(_, key) {
    var val = mdict[key];
    var key_oop = this.append_symbol_instance(key);
    pairs_oop.append([key_oop, val]);
  });
  return this.append_dict_with_pairs(pairs_oop);
}
instance_method append_symbol_dict: fun(mdict) {
  var pairs_oop = [];
  mdict.keys.sorted.each(fun(_, key) {
    var val = mdict[key];
    var key_oop = this.append_symbol_instance(key);
    var val_oop = this.append_string_instance(val);
    pairs_oop.append([key_oop, val_oop]);
  });
  return this.append_dict_with_pairs(pairs_oop);
}
instance_method append_dict_with_pairs: fun(pairs) {
  var frame_oop = this._append_dict_frame(pairs);
  var oop = this.append_dict_prologue(pairs.size, frame_oop);
  return oop;
}
instance_method _append_dict_frame: fun(pairs) {
  this.append_int(mec.FRAME_TYPE_ELEMENTS, null);
  this.append_int(pairs.size * 2 * bits.WSIZE, null);

  var oops = [];
  pairs.each(fun(_, entry) {
    var key = entry[0];
    var val = entry[1];
    if (Mirror.vtFor(key) == Integer or Mirror.vtFor(key) == LongNum) {
      oops.append(this.append_tagged_int(key, null));
    } else {
      oops.append(this.append_pointer_to(key, null));
    }
    if (Mirror.vtFor(val) == Integer or Mirror.vtFor(val) == LongNum) {
      this.append_tagged_int(val, null);
    } else {
      this.append_pointer_to(val, null);
    }
  });

  if (oops.size > 0) {
    return oops[0];
  } else {
    return null;
  }
}
instance_method append_empty_dict: fun() {
  return this.append_dict_prologue(0, null);
}

instance_method append_sym_dict_emiting_entries: fun(entries_mdict) {
  var pairs_oop = [];
  entries_mdict.keys.sorted.each(fun(_, key) {
    var entry = entries_mdict[key];
    var key_oop = this.append_symbol_instance(key);
    var val_oop = entry.fill(this);
    pairs_oop.append([key_oop, val_oop]);
  });
  return this.append_dict_with_pairs(pairs_oop);
}
instance_method dump: fun() {
  var addr = @base;
  @cells.each(fun(idx, x) {
    var v = x.value(null);
    io.print(addr.toString + ": " + bits.unpack(v.map(fun(x) { x.asChar })).toString);
    addr = addr + v.size;
  });
}

end

// // tests

// main: fun() {
//     var tb = VirtualMemory.new;
//     var c0 = tb.append_label_ref("Behavior", "Behavior");  // 100 -> 100
//     var c1 = tb.append_int(14, "Object");                  // 108 = 14
//     var c2 = tb.append_int(18, null);                      // 116 = 18
//     var c3 = tb.append_label_ref("Object", null);          // 124 -> 104
//     var c4 = tb.append_int(16, null);                      // 132 = 16
//     tb.append_pointer_to(c3, null);                        // 140 -> 124
//     tb.append_label_ref("Foo", null);                      // 148 -> 180 -- forward reference

//     tb.append_string("abceghijkl", null);                 // 156..164
//     tb.append_label_ref("Foo", null);                     // 172 -> 180 -- forward reference
//     var c9 = tb.append_int(21, "Foo");                    // 180 = 21
//     tb.append_pointer_to(c9, null);                       // 188 -> 180
//     tb.set_base(100);
//     tb.dump();
// }
